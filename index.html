<!doctype html>
<html lang="en">
<head>
  <!-- Basic SEO & Meta -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="Thinknex — Tools To Make Your Work Easy: 27 free client-side PDF tools to edit, convert, compress, sign and manage PDFs directly in your browser." />
  <meta name="keywords" content="PDF tools, merge PDF, split PDF, compress PDF, edit PDF, sign PDF, convert PDF, online PDF, client-side" />
  <!-- Placeholder for Google Search Console verification -->
  <!-- <meta name="google-site-verification" content="PUT_YOUR_CODE_HERE" /> -->

  <title>Thinknex — Tools To Make Your Work Easy (27 Free PDF Tools)</title>

  <!-- CSS variables and base styling -->
  <style>
    :root{
      --primary-red:#e5322d;
      --background-light:#f8f8fa;
      --bg:#ffffff;
      --muted:#6b6b6b;
      --card-shadow: 0 6px 18px rgba(17,17,17,0.06);
      --max-width:1200px;
      --radius:12px;
      --glass: rgba(255,255,255,0.7);
      --focus: 0 0 0 4px rgba(229,50,45,0.12);
    }
    /* Mobile-first */
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      background:linear-gradient(180deg,var(--background-light),#ffffff);
      color:#222;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      line-height:1.45;
      scroll-behavior: smooth;
    }
    a{color:var(--primary-red);text-decoration:none}
    .container{max-width:var(--max-width);margin:0 auto;padding:20px;}

    /* Header */
    header{
      position:sticky;top:0;z-index:60;
      backdrop-filter: blur(6px);
      background:rgba(255,255,255,0.8);
      border-bottom:1px solid rgba(0,0,0,0.04);
      transition: box-shadow .25s, background .25s;
    }
    header.scrolled{box-shadow:0 6px 18px rgba(0,0,0,0.06)}
    .nav{
      display:flex;align-items:center;justify-content:space-between;padding:12px 16px;
      gap:12px;
    }
    .brand{display:flex;align-items:center;gap:10px;font-weight:700}
    .logo-mark{
      width:40px;height:40px;border-radius:8px;background:linear-gradient(135deg,var(--primary-red),#ff6b6b);
      display:inline-flex;align-items:center;justify-content:center;color:white;font-weight:800;font-size:18px;
      box-shadow: var(--card-shadow);
    }
    nav.desktop{display:flex;gap:16px;align-items:center}
    .nav a{padding:8px 10px;border-radius:8px}
    .nav a:focus{outline:none;box-shadow:var(--focus)}
    /* hamburger */
    .hamburger{
      display:flex;align-items:center;gap:10px;border:0;background:none;
      padding:8px;border-radius:8px;
    }
    .hamburger .lines{width:26px;height:18px;position:relative}
    .lines span{position:absolute;height:2px;background:#222;left:0;right:0;border-radius:2px;transition:transform .25s,opacity .2s}
    .lines span:nth-child(1){top:0}
    .lines span:nth-child(2){top:8px}
    .lines span:nth-child(3){top:16px}
    .hamburger.open .lines span:nth-child(1){transform: translateY(8px) rotate(45deg)}
    .hamburger.open .lines span:nth-child(2){opacity:0}
    .hamburger.open .lines span:nth-child(3){transform: translateY(-8px) rotate(-45deg)}

    /* Mobile nav overlay */
    .mobile-nav{
      position:fixed;inset:0;background:rgba(0,0,0,0.55);display:none;z-index:80;
      align-items:center;justify-content:center;
    }
    .mobile-nav.open{display:flex}
    .mobile-nav .menu{background:white;border-radius:12px;padding:28px;width:90%;max-width:380px;box-shadow:var(--card-shadow);}
    .mobile-nav a{display:block;padding:12px 0;font-size:18px;border-bottom:1px solid #f0f0f0}

    /* Hero */
    .hero{padding:28px 16px;text-align:center;border-radius:10px;margin-top:12px;background:linear-gradient(180deg,rgba(255,255,255,0.9),rgba(248,248,250,0.9));}
    .hero h1{font-size:20px;margin:6px 0 0 0}
    .hero p{color:var(--muted);margin:10px auto;max-width:720px}
    .ad-728{margin:18px auto;border:2px dashed #ddd;height:90px;max-width:728px;display:flex;align-items:center;justify-content:center;color:#999;border-radius:8px}

    /* Tools grid */
    .tools{display:grid;gap:16px;margin-top:18px}
    .tool-card{
      background:white;border-radius:12px;padding:14px;box-shadow:var(--card-shadow);
      display:flex;flex-direction:column;gap:12px;transition:transform .22s,box-shadow .22s,border-color .22s;
      border:1px solid transparent;cursor:pointer;
    }
    .tool-card:hover{transform: translateY(-6px) scale(1.01);box-shadow:0 12px 30px rgba(17,17,17,0.08);border-color:rgba(229,50,45,0.08)}
    .tool-head{display:flex;gap:12px;align-items:center}
    .tool-icon{width:56px;height:56px;border-radius:10px;background:linear-gradient(180deg,#fff,#f7f7f7);display:flex;align-items:center;justify-content:center;font-weight:700;border:1px solid #f0f0f0}
    .tool-title{font-size:15px;font-weight:700}
    .tool-desc{color:var(--muted);font-size:13px}
    .badge-new{background:var(--primary-red);color:white;padding:6px 8px;border-radius:999px;font-size:11px}

    /* Modal */
    .modal-overlay{position:fixed;inset:0;background:rgba(10,10,10,0.45);display:none;align-items:center;justify-content:center;z-index:120;padding:18px}
    .modal-overlay.open{display:flex}
    .modal{
      background:white;border-radius:12px;max-width:900px;width:100%;max-height:90vh;overflow:hidden;display:grid;grid-template-columns:1fr 260px;
      box-shadow:0 20px 60px rgba(0,0,0,0.3);
      animation:fadeIn .22s ease both;
    }
    @keyframes fadeIn{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:none}}
    .modal .content{padding:18px;overflow:auto}
    .modal .sidebar{background:linear-gradient(180deg,#fcfcfc,#fafafa);padding:16px;border-left:1px solid #f0f0f0}
    .modal .close{position:absolute;right:18px;top:14px;border-radius:8px;padding:6px 8px;background:transparent;border:0}
    .dropzone{border:2px dashed #e9e9e9;padding:18px;border-radius:10px;text-align:center;transition:background .18s,border-color .18s}
    .dropzone.dragover{background:rgba(229,50,45,0.04);border-color:rgba(229,50,45,0.28)}
    .file-list{margin-top:12px}
    .file-item{display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:8px;border:1px solid #f0f0f0;margin-top:8px}
    .options{margin-top:12px;display:flex;flex-direction:column;gap:8px}
    .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 12px;border-radius:10px;border:0;background:var(--primary-red);color:white;font-weight:700;cursor:pointer}
    .btn.secondary{background:#f5f5f5;color:#222}
    .btn[disabled]{opacity:0.55;cursor:not-allowed}

    /* loader */
    .loader{display:flex;align-items:center;gap:12px}
    .spinner{width:32px;height:32px;border-radius:50%;border:4px solid rgba(0,0,0,0.08);border-top-color:var(--primary-red);animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}

    /* footer */
    footer{margin-top:34px;background:linear-gradient(180deg,#fff,#fafafa);padding:28px;border-top:1px solid #f0f0f0}
    .footer-grid{display:grid;gap:18px}
    .footer-grid h4{margin:0 0 8px 0}
    .copyright{color:var(--muted);font-size:13px;margin-top:14px}

    /* About article */
    .article{background:white;border-radius:12px;padding:18px;box-shadow:var(--card-shadow);margin-top:22px}
    .article h2,h3{margin:8px 0}

    /* responsive grid columns */
    @media (min-width:480px){
      .tools{grid-template-columns: repeat(auto-fill,minmax(220px,1fr));}
    }
    @media (min-width:768px){
      .tools{grid-template-columns: repeat(auto-fill,minmax(250px,1fr));}
      .modal{grid-template-columns:1fr 260px}
      nav.desktop{display:flex}
      .hamburger{display:none}
    }
    @media (max-width:767px){
      nav.desktop{display:none}
      .modal{grid-template-columns:1fr}
      .modal .sidebar{display:none}
      .ad-728{display:none}
    }
    @media (max-width:480px){
      .hero h1{font-size:18px}
      .tool-icon{width:48px;height:48px}
      .logo-mark{width:36px;height:36px;font-size:16px}
      .container{padding:12px}
    }

    /* focus for keyboard accessibility */
    .focusable:focus{outline:none;box-shadow:var(--focus)}
  </style>

  <!-- Load dependencies from CDN (versions requested) -->
  <!-- pdf-lib -->
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <!-- pdf.js (rendering) -->
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/pdf.min.js"></script>
  <!-- tesseract.js (optional, not used in core above but available) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <!-- html2pdf -->
  <script src="https://cdn.jsdelivr.net/npm/html2pdf.js@0.10.1/dist/html2pdf.bundle.min.js"></script>
  <!-- mammoth -->
  <script src="https://cdn.jsdelivr.net/npm/mammoth@1.6.0/mammoth.browser.min.js"></script>
  <!-- xlsx (if needed) -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <!-- pptxgenjs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pptxgenjs/3.12.0/pptxgen.min.js"></script>
  <!-- fabric.js -->
  <script src="https://cdn.jsdelivr.net/npm/fabric@5.3.0/dist/fabric.min.js"></script>
  <!-- jszip -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- Commented placeholder for Google Analytics -->
  <!--
  <script>
    // Paste Google Analytics snippet here
  </script>
  -->
</head>
<body>
  <header id="site-header" aria-label="Main header">
    <div class="container nav">
      <div class="brand" aria-hidden="false">
        <div class="logo-mark">OT</div>
        <div>
          <div style="font-size:14px">Thinknex</div>
          <div style="font-size:11px;color:var(--muted)">Tools To Make Your Work Easy</div>
        </div>
      </div>

      <nav class="desktop" role="navigation" aria-label="Primary">
        <a href="#home" class="focusable">Home</a>
        <a href="#tools" class="focusable">All Tools</a>
        <a href="#about" class="focusable">About Us</a>
        <a href="#contact" class="focusable">Contact Us</a>
      </nav>

      <button class="hamburger focusable" id="hamburger" aria-label="Open menu" aria-expanded="false">
        <div class="lines"><span></span><span></span><span></span></div>
      </button>
    </div>
  </header>

  <!-- Mobile nav -->
  <div class="mobile-nav" id="mobile-nav" aria-hidden="true">
    <div class="menu" role="menu">
      <a href="#home">Home</a>
      <a href="#tools">All Tools</a>
      <a href="#about">About Us</a>
      <a href="#contact">Contact Us</a>
      <div style="margin-top:12px;color:#555;font-size:14px">Process files locally in your browser — no uploads.</div>
    </div>
  </div>

  <!-- Main -->
  <main class="container" id="home" role="main">
    <section class="hero" id="hero">
      <h1>Every tool you need to work with PDFs in one place.</h1>
      <p>Free, fast, and secure PDF tools — work entirely in your browser. Merge, split, compress, convert, edit, sign, watermark and more without installing software.</p>

      <div class="ad-728" role="img" aria-label="Advertisement placeholder">Advertisement — 728 × 90</div>
    </section>

    <!-- Tools grid -->
    <section class="tools" id="tools" aria-labelledby="tools-heading" style="margin-top:16px">
      <!-- Tool cards generated by JS -->
    </section>

    <!-- About / Article -->
    <article class="article" id="about" tabindex="0">
      <h2>Thinknex</h2>
      <p>Thinknex provides a suite of free online PDF tools designed to make everyday PDF tasks simple and private. All file processing happens inside your browser — files are never uploaded to a server.</p>

      <h3>Core features</h3>
      <ul>
        <li><strong>Merge & Split:</strong> Combine multiple PDFs or split a PDF into separate pages/ranges.</li>
        <li><strong>Compress:</strong> Reduce PDF file size by re-encoding page images.</li>
        <li><strong>Convert:</strong> Convert between PDF and other formats (Word, PowerPoint, images).</li>
        <li><strong>Edit & Sign:</strong> Draw, add text, annotate, and embed signatures using an integrated canvas editor.</li>
        <li><strong>Watermark & Rotate:</strong> Securely add watermarks and rotate pages.</li>
      </ul>

      <h3>Why use client-side tools?</h3>
      <p>Processing files locally ensures maximum privacy and control — nothing leaves your device. These tools are ideal for sensitive documents and quick edits without installing software.</p>
    </article>

    <!-- Contact anchor -->
    <section id="contact" style="margin-top:18px">
      <h3>Contact Us</h3>
      <p>Questions or feedback? Email: <a href="mailto:info@thinknex.org">info@thinknex.org</a></p>
    </section>
  </main>

  <!-- Modal (tool interactions) -->
  <div class="modal-overlay" id="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Tool modal">
      <div class="content" id="modal-content">
        <button class="close focusable" id="modal-close" aria-label="Close modal">✕</button>
        <h2 id="modal-title">Tool Title</h2>

        <div class="dropzone focusable" id="dropzone" tabindex="0">
          <div style="font-weight:700">Drag & drop files here</div>
          <div style="color:var(--muted);font-size:13px;margin-top:6px">or <label for="file-input" style="color:var(--primary-red);cursor:pointer">click to select</label></div>
          <input id="file-input" type="file" style="display:none" />
        </div>

        <div class="file-list" id="file-list" aria-live="polite"></div>

        <div class="options" id="options-area"></div>

        <div style="margin-top:12px;display:flex;gap:12px;align-items:center">
          <button class="btn" id="process-btn" disabled>Process</button>
          <button class="btn secondary" id="reset-btn">Reset</button>
          <div id="loader-area" style="margin-left:auto"></div>
        </div>

        <div id="output-area" style="margin-top:12px"></div>
      </div>

      <aside class="sidebar" id="modal-sidebar" aria-hidden="true">
        <div style="font-weight:700">Advertisement</div>
        <div style="border:2px dashed #ddd;height:400px;display:flex;align-items:center;justify-content:center;border-radius:8px;margin-top:12px">Advertisement 200 × 400</div>
      </aside>
    </div>
  </div>

  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="footer-grid" style="grid-template-columns:repeat(auto-fit,minmax(200px,1fr))">
        <div>
          <h4>About Tools Thinknex</h4>
          <p style="color:var(--muted)">Process files directly in your browser without uploading anything. Free and privacy-focused.</p>
        </div>
        <div>
          <h4>Tools</h4>
          <ul style="padding-left:18px;margin:0;color:var(--muted)">
            <li><a href="#tools">All PDF Tools</a></li>
            <li><a href="#about">Why use client-side tools</a></li>
          </ul>
        </div>
        <div>
          <h4>Company</h4>
          <ul style="padding-left:18px;margin:0;color:var(--muted)">
            <li><a href="#">Privacy Policy</a></li>
            <li><a href="#">Terms of Service</a></li>
          </ul>
        </div>
        <div>
          <h4>Contact</h4>
          <p style="color:var(--muted)">info@thinknex.org</p>
        </div>
      </div>

      <div class="copyright">© 2024 Tools To Make Your Work Easy. All Rights Reserved.</div>
    </div>
  </footer>

  <!-- Core JS -->
  <script>
    /****************************************************************
     * Thinknex — Tools To Make Your Work Easy
     * Single file app implementing 27 PDF tools (many fully client-side)
     *
     * Save as thinknex.html and open in modern browsers.
     *
     * Notes:
     * - Uses pdf-lib, pdf.js, pptxgenjs, mammoth, html2pdf, fabric, etc via CDN.
     * - All operations occur client-side (no uploads).
     * - Some operations rasterize pages for simplicity (edit/sign). Advanced vector edits would need deeper pdf-lib manipulation.
     ****************************************************************/

    // Wait for DOM
    document.addEventListener('DOMContentLoaded', async () => {
      // Configure pdf.js worker
      if (window['pdfjsLib']) {
        // use the same CDN location - pdfjs-dist automatically determines worker src from location of script by default.
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/pdf.worker.min.js';
      }

      const toolsContainer = document.getElementById('tools');
      const modalOverlay = document.getElementById('modal-overlay');
      const modalTitle = document.getElementById('modal-title');
      const dropzone = document.getElementById('dropzone');
      const fileInput = document.getElementById('file-input');
      const fileListEl = document.getElementById('file-list');
      const optionsArea = document.getElementById('options-area');
      const processBtn = document.getElementById('process-btn');
      const resetBtn = document.getElementById('reset-btn');
      const loaderArea = document.getElementById('loader-area');
      const outputArea = document.getElementById('output-area');
      const modalClose = document.getElementById('modal-close');
      const modalSidebar = document.getElementById('modal-sidebar');

      // Utility functions
      function showLoader(text = 'Processing...') {
        loaderArea.innerHTML = '';
        const loader = document.createElement('div');
        loader.className = 'loader';
        loader.innerHTML = '<div class="spinner" aria-hidden="true"></div><div style="color:var(--muted)">'+text+'</div>';
        loaderArea.appendChild(loader);
      }
      function hideLoader() { loaderArea.innerHTML = ''; }
      function showError(msg) {
        alert(msg);
      }
      function createDownloadLink(blobOrUrl, filename, mimeType) {
        const a = document.createElement('a');
        a.style.display = 'inline-block';
        a.style.marginRight = '8px';
        if (typeof blobOrUrl === 'string') {
          a.href = blobOrUrl;
        } else {
          a.href = URL.createObjectURL(blobOrUrl);
        }
        a.download = filename;
        a.textContent = 'Download ' + filename;
        a.className = 'btn';
        outputArea.appendChild(a);
      }

      // IntersectionObserver reveal animations
      const io = new IntersectionObserver((entries) => {
        entries.forEach(e => {
          if (e.isIntersecting && e.intersectionRatio > 0.1) {
            e.target.classList.add('active');
            io.unobserve(e.target);
          }
        });
      }, { threshold: 0.1 });

      // Header scroll shadow
      const header = document.getElementById('site-header');
      window.addEventListener('scroll', () => {
        if (window.scrollY > 50) header.classList.add('scrolled'); else header.classList.remove('scrolled');
      });

      // Mobile nav toggle
      const hamburger = document.getElementById('hamburger');
      const mobileNav = document.getElementById('mobile-nav');
      hamburger.addEventListener('click', () => {
        const open = hamburger.classList.toggle('open');
        hamburger.setAttribute('aria-expanded', open ? 'true' : 'false');
        mobileNav.classList.toggle('open', open);
      });
      mobileNav.addEventListener('click', (e) => {
        if (e.target === mobileNav) {
          mobileNav.classList.remove('open');
          hamburger.classList.remove('open');
          hamburger.setAttribute('aria-expanded','false');
        }
      });

      // Modal open/close utilities
      let activeTool = null;
      const modalState = {
        files: [], // {file, name, data}
        options: {},
        edits: {}, // for edit tool
      };

      function resetModalState() {
        modalState.files = [];
        modalState.options = {};
        modalState.edits = {};
        fileListEl.innerHTML = '';
        optionsArea.innerHTML = '';
        outputArea.innerHTML = '';
        processBtn.disabled = true;
        hideLoader();
      }

      function openModal(tool) {
        activeTool = tool;
        modalTitle.textContent = tool.title;
        modalOverlay.classList.add('open');
        modalOverlay.setAttribute('aria-hidden','false');
        resetModalState();
        // Setup file input attributes based on tool settings
        fileInput.accept = tool.fileType || '*/*';
        fileInput.multiple = !!tool.multiple;
        // Show options UI
        if (typeof tool.options === 'function') {
          tool.options(optionsArea, modalState);
        } else {
          optionsArea.innerHTML = '';
        }
        // Show sidebar ad only on desktop
        if (window.innerWidth < 768) modalSidebar.style.display = 'none';
        else modalSidebar.style.display = 'block';

        // Tool-specific onFileSelect
        if (tool.onOpen) tool.onOpen(modalState, {showLoader, hideLoader, showError});
      }

      function closeModal() {
        modalOverlay.classList.remove('open');
        modalOverlay.setAttribute('aria-hidden','true');
        activeTool = null;
        resetModalState();
      }

      modalClose.addEventListener('click', closeModal);
      modalOverlay.addEventListener('click', (e) => {
        if (e.target === modalOverlay) closeModal();
      });
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modalOverlay.classList.contains('open')) closeModal();
      });

      // File handling
      function updateFileListUI() {
        fileListEl.innerHTML = '';
        modalState.files.forEach((f, idx) => {
          const div = document.createElement('div');
          div.className = 'file-item';
          const left = document.createElement('div');
          left.innerHTML = `<div style="font-weight:700">${f.name}</div><div style="color:var(--muted);font-size:12px">${(f.file.size/1024|0)} KB</div>`;
          const right = document.createElement('div');
          const removeBtn = document.createElement('button');
          removeBtn.className = 'btn secondary';
          removeBtn.textContent = 'Remove';
          removeBtn.addEventListener('click', () => {
            modalState.files.splice(idx,1);
            updateFileListUI();
            processBtn.disabled = modalState.files.length === 0;
          });
          right.appendChild(removeBtn);
          div.appendChild(left);div.appendChild(right);
          fileListEl.appendChild(div);
        });
      }

      async function handleFiles(fileList) {
        const files = Array.from(fileList);
        // basic validation
        if (!activeTool) return;
        if (!activeTool.multiple && files.length > 1) {
          showError('This tool accepts only one file at a time.');
          return;
        }
        // map files into state
        for (const f of files) {
          modalState.files.push({file: f, name: f.name});
        }
        updateFileListUI();
        processBtn.disabled = modalState.files.length === 0;
        if (activeTool.onFileSelect) activeTool.onFileSelect(modalState, {showLoader, hideLoader, showError});
      }

      // drag/drop
      dropzone.addEventListener('dragover', (e) => { e.preventDefault(); dropzone.classList.add('dragover'); });
      dropzone.addEventListener('dragleave', (e) => { dropzone.classList.remove('dragover'); });
      dropzone.addEventListener('drop', (e) => {
        e.preventDefault(); dropzone.classList.remove('dragover');
        handleFiles(e.dataTransfer.files);
      });
      dropzone.addEventListener('click', () => fileInput.click());
      fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

      // Process button
      processBtn.addEventListener('click', async () => {
        if (!activeTool) return;
        try {
          outputArea.innerHTML = '';
          showLoader('Processing...');
          await activeTool.process(modalState, {
            pdfLib: window.PDFLib,
            pdfjsLib: window.pdfjsLib,
            PPTX: window.PptxGenJS,
            mammoth: window.mammoth,
            html2pdf: window.html2pdf,
            fabric: window.fabric,
            showLoader, hideLoader, showError, createDownloadLink
          });
        } catch (err) {
          console.error(err);
          showError('An error occurred: ' + (err && err.message ? err.message : String(err)));
        } finally {
          hideLoader();
        }
      });

      resetBtn.addEventListener('click', resetModalState);

      /****************************************************************
       * Utility helpers for PDF rendering and conversion
       ****************************************************************/
      async function readFileAsArrayBuffer(file) {
        return new Promise((res, rej) => {
          const r = new FileReader();
          r.onload = () => res(r.result);
          r.onerror = rej;
          r.readAsArrayBuffer(file);
        });
      }
      async function readFileAsDataUrl(file) {
        return new Promise((res, rej) => {
          const r = new FileReader();
          r.onload = () => res(r.result);
          r.onerror = rej;
          r.readAsDataURL(file);
        });
      }

      // Render a PDF page to canvas and return the canvas element
      async function renderPdfPageToCanvas(pdfData, pageNum, scale = 1.0) {
        const loadingTask = pdfjsLib.getDocument({data: pdfData});
        const pdfDoc = await loadingTask.promise;
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({scale});
        const canvas = document.createElement('canvas');
        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        const ctx = canvas.getContext('2d');
        const renderContext = {
          canvasContext: ctx,
          viewport
        };
        await page.render(renderContext).promise;
        return canvas;
      }

      /****************************************************************
       * Tool Implementations
       * Each tool: {title, desc, icon, fileType, multiple, options(), process(), onFileSelect()}
       ****************************************************************/
      const toolImplementations = {
        'merge': {
          title:'Merge PDF',
          desc:'Combine multiple PDF files into one merged PDF.',
          icon:'⇄',
          fileType:'.pdf',
          multiple:true,
          options(container) {
            container.innerHTML = `<div style="color:var(--muted)">No options for this tool.</div>`;
          },
          async process(state, libs) {
            if (state.files.length < 2) { showError('Select at least two PDFs to merge.'); return; }
            // read files as array buffers
            const pdfDoc = await libs.pdfLib.PDFDocument.create();
            for (const f of state.files) {
              const arr = await readFileAsArrayBuffer(f.file);
              const donor = await libs.pdfLib.PDFDocument.load(arr);
              const copiedPages = await pdfDoc.copyPages(donor, donor.getPageIndices());
              copiedPages.forEach(p => pdfDoc.addPage(p));
            }
            const out = await pdfDoc.save();
            createDownloadLink(new Blob([out], {type:'application/pdf'}), 'merged.pdf', 'application/pdf');
          }
        },

        'split': {
          title:'Split PDF',
          desc:'Split a PDF by page ranges (e.g., 1-3,5,7-9).',
          icon:'⌇',
          fileType:'.pdf',
          multiple:false,
          options(container, state) {
            container.innerHTML = `
              <label style="font-weight:700">Page ranges (e.g. 1-3,5)</label>
              <input id="split-ranges" placeholder="e.g., 1-3,5" style="padding:8px;border-radius:8px;border:1px solid #eee" />
            `;
          },
          async process(state, libs) {
            if (state.files.length === 0) { showError('Please select a PDF to split.'); return; }
            const rangesInput = document.getElementById('split-ranges').value.trim();
            if (!rangesInput) { showError('Enter page ranges like 1-3,5'); return; }
            const arr = await readFileAsArrayBuffer(state.files[0].file);
            const srcPdf = await libs.pdfLib.PDFDocument.load(arr);
            const total = srcPdf.getPageCount();
            // parse ranges
            const ranges = rangesInput.split(',').map(s => s.trim()).filter(Boolean);
            const pagesToExtract = new Set();
            for (const r of ranges) {
              if (r.includes('-')) {
                const [a,b] = r.split('-').map(x => parseInt(x,10));
                if (isNaN(a) || isNaN(b) || a<1 || b>total || a>b) { showError('Invalid range: '+r); return; }
                for (let i=a;i<=b;i++) pagesToExtract.add(i-1);
              } else {
                const p = parseInt(r,10);
                if (isNaN(p) || p<1 || p>total) { showError('Invalid page: '+r); return; }
                pagesToExtract.add(p-1);
              }
            }
            const outPdf = await libs.pdfLib.PDFDocument.create();
            const indices = Array.from(pagesToExtract);
            const copied = await outPdf.copyPages(srcPdf, indices);
            copied.forEach(p=>outPdf.addPage(p));
            const out = await outPdf.save();
            createDownloadLink(new Blob([out], {type:'application/pdf'}), 'split.pdf', 'application/pdf');
          }
        },

        'compress': {
          title:'Compress PDF',
          desc:'Reduce PDF size by re-rendering pages at lower quality and embedding images.',
          icon:'🗜️',
          fileType:'.pdf',
          multiple:false,
          options(container, state) {
            container.innerHTML = `
              <label style="font-weight:700">Quality (lower → smaller size)</label>
              <input id="compress-quality" type="range" min="0.2" max="1" step="0.05" value="0.7" />
              <div style="color:var(--muted);font-size:13px">Tip: choose lower values for smaller files (may reduce readability).</div>
            `;
          },
          async process(state, libs) {
            if (state.files.length === 0) { showError('Please select a PDF to compress.'); return; }
            const quality = parseFloat(document.getElementById('compress-quality').value || '0.7');
            // load source PDF, render each page to canvas with lower scale, then create a new pdf with images
            const arr = await readFileAsArrayBuffer(state.files[0].file);
            const loadingTask = libs.pdfjsLib.getDocument({data:arr});
            const pdfDoc = await loadingTask.promise;
            const newPdf = await libs.pdfLib.PDFDocument.create();
            const total = pdfDoc.numPages;
            for (let i=1;i<=total;i++) {
              showLoader(`Compressing page ${i}/${total}...`);
              const page = await pdfDoc.getPage(i);
              // approximate scale depending on quality
              const viewport = page.getViewport({scale: 1.0 * quality});
              const canvas = document.createElement('canvas');
              canvas.width = Math.floor(viewport.width);
              canvas.height = Math.floor(viewport.height);
              const ctx = canvas.getContext('2d');
              await page.render({canvasContext:ctx, viewport}).promise;
              // convert to jpeg data url with quality
              const dataUrl = canvas.toDataURL('image/jpeg', quality);
              const imgBytes = await (await fetch(dataUrl)).arrayBuffer();
              const img = await newPdf.embedJpg(imgBytes);
              const pageDims = { width: img.width, height: img.height };
              const pdfPage = newPdf.addPage([pageDims.width, pageDims.height]);
              pdfPage.drawImage(img, {
                x:0,y:0,width:pageDims.width,height:pageDims.height
              });
            }
            hideLoader();
            const out = await newPdf.save();
            createDownloadLink(new Blob([out],{type:'application/pdf'}),'compressed.pdf','application/pdf');
          }
        },

        'pdf-to-pptx': {
          title:'PDF to PowerPoint',
          desc:'Convert PDF pages into PNG slides inside a PPTX file.',
          icon:'📊',
          fileType:'.pdf',
          multiple:false,
          options(container) {
            container.innerHTML = `<div style="color:var(--muted)">Each PDF page becomes a slide. Large PDFs may take longer.</div>`;
          },
          async process(state, libs) {
            if (state.files.length===0){ showError('Select a PDF first'); return; }
            const arr = await readFileAsArrayBuffer(state.files[0].file);
            const loadingTask = libs.pdfjsLib.getDocument({data:arr});
            const pdfDoc = await loadingTask.promise;
            const pptx = new libs.PPTX();
            const total = pdfDoc.numPages;
            for (let i=1;i<=total;i++) {
              showLoader(`Rendering page ${i}/${total}...`);
              const page = await pdfDoc.getPage(i);
              const viewport = page.getViewport({scale:1.5});
              const canvas = document.createElement('canvas');
              canvas.width = Math.floor(viewport.width);
              canvas.height = Math.floor(viewport.height);
              const ctx = canvas.getContext('2d');
              await page.render({canvasContext:ctx,viewport}).promise;
              const dataUrl = canvas.toDataURL('image/png');
              const slide = pptx.addSlide();
              // add full-slide image
              slide.addImage({data:dataUrl, x:0, y:0, w:10, h:5.625}); // 16:9 approx
            }
            hideLoader();
            const outName = 'converted.pptx';
            await pptx.writeFile({fileName: outName});
            // pptxgenjs triggers download automatically in browsers when writeFile is used.
          }
        },

        'pdf-to-word': {
          title:'PDF to Word (text only)',
          desc:'Extract text from PDF pages and produce a plain .txt file (formatting not preserved).',
          icon:'📄',
          fileType:'.pdf',
          multiple:false,
          options(container) {
            container.innerHTML = `<div style="color:var(--muted)">This tool extracts plain text from PDF pages using pdf.js text content. Formatting and images are not preserved.</div>`;
          },
          async process(state, libs) {
            if (state.files.length===0){ showError('Select a PDF'); return; }
            const arr = await readFileAsArrayBuffer(state.files[0].file);
            const loadingTask = libs.pdfjsLib.getDocument({data:arr});
            const pdfDoc = await loadingTask.promise;
            const total = pdfDoc.numPages;
            let textAcc = '';
            for (let i=1;i<=total;i++) {
              showLoader(`Extracting text from page ${i}/${total}...`);
              const page = await pdfDoc.getPage(i);
              const content = await page.getTextContent();
              const pageText = content.items.map(it => it.str).join(' ');
              textAcc += `\n\n----- Page ${i} -----\n\n` + pageText;
            }
            hideLoader();
            const blob = new Blob([textAcc], {type:'text/plain'});
            createDownloadLink(blob, 'extracted.txt', 'text/plain');
          }
        },

        'word-to-pdf': {
          title:'Word to PDF',
          desc:'Convert a DOCX file to PDF using mammoth and html2pdf (client-side).',
          icon:'📝→📄',
          fileType:'.docx',
          multiple:false,
          options(container) {
            container.innerHTML = `<div style="color:var(--muted)">Converts DOCX to HTML (mammoth) then to PDF. Layout may vary.</div>`;
          },
          async process(state, libs) {
            if (state.files.length === 0) { showError('Select a .docx file.'); return; }
            const arrayBuffer = await readFileAsArrayBuffer(state.files[0].file);
            // convert with mammoth
            showLoader('Converting DOCX to HTML...');
            const result = await libs.mammoth.convertToHtml({arrayBuffer});
            const html = result.value;
            // create hidden element to convert to PDF
            const wrapper = document.createElement('div');
            wrapper.style.padding = '12px';
            wrapper.innerHTML = html;
            document.body.appendChild(wrapper);
            hideLoader();
            showLoader('Rendering PDF...');
            await libs.html2pdf().from(wrapper).save('word.pdf');
            document.body.removeChild(wrapper);
            hideLoader();
          }
        },

        'edit': {
          title:'Edit PDF (canvas-based)',
          desc:'Annotate pages, add text, draw shapes. Edits are rasterized into a new PDF (visual edits preserved).',
          icon:'✎',
          fileType:'.pdf',
          multiple:false,
          onOpen(state, helpers) {
            // initialize edits map
            state.edits = {};
          },
          options(container, state) {
            container.innerHTML = `
              <div style="font-weight:700">Editor</div>
              <div style="color:var(--muted);font-size:13px">Draw or add text to pages. Use Prev/Next to navigate pages.</div>
              <div style="display:flex;gap:8px;margin-top:8px">
                <button id="edit-prev" class="btn secondary">Prev</button>
                <button id="edit-next" class="btn secondary">Next</button>
                <button id="edit-add-text" class="btn secondary">Add Text</button>
              </div>
              <div id="edit-canvas-wrap" style="margin-top:12px;border:1px solid #f0f0f0;padding:8px;border-radius:8px;min-height:200px;display:flex;align-items:center;justify-content:center">
                <div style="color:var(--muted)">Upload PDF to start editing.</div>
              </div>
            `;
          },
          async onFileSelect(state, helpers) {
            // Create fabric canvas per page when file loaded
            const wrap = document.getElementById('edit-canvas-wrap');
            wrap.innerHTML = '<div style="color:var(--muted)">Preparing editor...</div>';
            const arr = await readFileAsArrayBuffer(state.files[0].file);
            const loadingTask = pdfjsLib.getDocument({data:arr});
            const pdfDoc = await loadingTask.promise;
            const total = pdfDoc.numPages;
            state._edit_total = total;
            state._edit_pdf_arr = arr;
            // prepare canvases per page (lazy render)
            state._current_edit_page = 1;
            async function renderPageToFabric(pageNum) {
              showLoader(`Rendering page ${pageNum}/${total}...`);
              const page = await pdfDoc.getPage(pageNum);
              const viewport = page.getViewport({scale:1.5});
              const canvas = document.createElement('canvas');
              canvas.width = Math.floor(viewport.width);
              canvas.height = Math.floor(viewport.height);
              const ctx = canvas.getContext('2d');
              await page.render({canvasContext:ctx,viewport}).promise;
              // create fabric overlay
              wrap.innerHTML = '';
              const container = document.createElement('div');
              container.style.position='relative';
              container.style.width = Math.min(800, canvas.width) + 'px';
              container.style.overflow = 'auto';
              const bgCanvas = document.createElement('canvas');
              bgCanvas.width = canvas.width;
              bgCanvas.height = canvas.height;
              bgCanvas.style.maxWidth = '100%';
              bgCanvas.getContext('2d').drawImage(canvas,0,0);
              bgCanvas.style.display='block';
              // create fabric canvas overlay
              const overlay = document.createElement('canvas');
              overlay.width = canvas.width;
              overlay.height = canvas.height;
              overlay.style.position='absolute';
              overlay.style.left='0';
              overlay.style.top='0';
              overlay.style.maxWidth='100%';
              container.appendChild(bgCanvas);
              container.appendChild(overlay);
              wrap.appendChild(container);
              // init fabric
              const f = new fabric.Canvas(overlay, {isDrawingMode:true, selection:true});
              f.setHeight(canvas.height); f.setWidth(canvas.width);
              // set brush
              f.freeDrawingBrush.width = 3;
              f.freeDrawingBrush.color = '#e5322d';
              // store fabric instance
              if (!state._fabricMap) state._fabricMap = {};
              state._fabricMap[pageNum] = {canvasBg: bgCanvas, fabric: f, width: canvas.width, height: canvas.height};
              hideLoader();
            }
            await renderPageToFabric(1);
            // prev/next handlers
            document.getElementById('edit-prev').onclick = async () => {
              if (state._current_edit_page <= 1) return;
              state._current_edit_page--;
              if (state._fabricMap && state._fabricMap[state._current_edit_page]) {
                // show cached
                const wrap = document.getElementById('edit-canvas-wrap');
                wrap.innerHTML = '';
                const map = state._fabricMap[state._current_edit_page];
                const container = document.createElement('div');
                container.style.position='relative'; container.style.width = Math.min(800,map.width) + 'px'; container.style.overflow='auto';
                const bg = map.canvasBg; const overlay = map.fabric.lowerCanvasEl;
                overlay.style.position='absolute'; overlay.style.left='0'; overlay.style.top='0'; overlay.style.maxWidth='100%';
                bg.style.maxWidth='100%';
                container.appendChild(bg); container.appendChild(overlay);
                wrap.appendChild(container);
              } else {
                await renderPageToFabric(state._current_edit_page);
              }
            };
            document.getElementById('edit-next').onclick = async () => {
              if (state._current_edit_page >= state._edit_total) return;
              state._current_edit_page++;
              if (state._fabricMap && state._fabricMap[state._current_edit_page]) {
                const wrap = document.getElementById('edit-canvas-wrap');
                wrap.innerHTML = '';
                const map = state._fabricMap[state._current_edit_page];
                const container = document.createElement('div');
                container.style.position='relative'; container.style.width = Math.min(800,map.width) + 'px'; container.style.overflow='auto';
                const bg = map.canvasBg; const overlay = map.fabric.lowerCanvasEl;
                overlay.style.position='absolute'; overlay.style.left='0'; overlay.style.top='0'; overlay.style.maxWidth='100%';
                bg.style.maxWidth='100%';
                container.appendChild(bg); container.appendChild(overlay);
                wrap.appendChild(container);
              } else {
                await renderPageToFabric(state._current_edit_page);
              }
            };
            document.getElementById('edit-add-text').onclick = () => {
              const map = state._fabricMap[state._current_edit_page];
              const t = new fabric.Textbox('Edit text', {
                left:50, top:50, width:200, fontSize:18, fill:'#e5322d'
              });
              map.fabric.add(t);
              map.fabric.renderAll();
            };
            processBtn.disabled = false;
          },
          async process(state, libs) {
            // For editing, we'll rasterize each page into an image combining background (pdf page) and fabric drawing, then embed into a new PDF.
            if (!state._fabricMap) { showError('Editor has no content.'); return; }
            const total = state._edit_total || Object.keys(state._fabricMap).length;
            const newPdf = await libs.pdfLib.PDFDocument.create();
            for (let i=1;i<=total;i++) {
              showLoader(`Saving page ${i}/${total}...`);
              const map = state._fabricMap[i];
              if (!map) {
                // render page if missing
                continue;
              }
              // merge bg and overlay into one canvas
              const merged = document.createElement('canvas');
              merged.width = map.width; merged.height = map.height;
              const ctx = merged.getContext('2d');
              // draw bg
              ctx.drawImage(map.canvasBg, 0, 0);
              // draw overlay (fabric)
              const overlayDataUrl = map.fabric.toDataURL({format:'png'});
              const img = new Image();
              await new Promise((res,rej) => {
                img.onload = () => { ctx.drawImage(img,0,0); res(); };
                img.onerror = rej;
                img.src = overlayDataUrl;
              });
              const imgBytes = await (await fetch(merged.toDataURL('image/png'))).arrayBuffer();
              const embedded = await newPdf.embedPng(imgBytes);
              const page = newPdf.addPage([embedded.width, embedded.height]);
              page.drawImage(embedded,{x:0,y:0,width:embedded.width,height:embedded.height});
            }
            hideLoader();
            const out = await newPdf.save();
            createDownloadLink(new Blob([out],{type:'application/pdf'}),'edited.pdf','application/pdf');
          }
        },

        'sign': {
          title:'Sign PDF',
          desc:'Draw a signature and embed it on the first page of the PDF.',
          icon:'✍️',
          fileType:'.pdf',
          multiple:false,
          options(container, state) {
            container.innerHTML = `
              <div style="font-weight:700">Signature</div>
              <div id="sig-wrap" style="border:1px solid #f0f0f0;border-radius:8px;padding:8px;margin-top:8px">
                <canvas id="sig-canvas" width="600" height="160" style="max-width:100%;border:1px solid #eee"></canvas>
                <div style="margin-top:8px;display:flex;gap:8px">
                  <button id="sig-clear" class="btn secondary">Clear</button>
                  <label style="display:inline-flex;align-items:center;gap:8px">X: <input id="sig-x" value="50" style="width:60px;padding:6px;border-radius:8px;border:1px solid #eee" /> Y: <input id="sig-y" value="50" style="width:60px;padding:6px;border-radius:8px;border:1px solid #eee" /> Scale: <input id="sig-scale" value="0.6" style="width:60px;padding:6px;border-radius:8px;border:1px solid #eee" /></label>
                </div>
              </div>
            `;
            // init fabric signature canvas
            setTimeout(()=> {
              const c = document.getElementById('sig-canvas');
              state._sigFabric = new fabric.Canvas(c, {isDrawingMode:true});
              state._sigFabric.freeDrawingBrush.width = 3;
              state._sigFabric.freeDrawingBrush.color = '#000000';
              document.getElementById('sig-clear').onclick = () => state._sigFabric.clear();
            }, 50);
          },
          async process(state, libs) {
            if (state.files.length === 0) { showError('Select a PDF to sign'); return; }
            if (!state._sigFabric) { showError('Signature canvas not ready'); return; }
            const sigDataUrl = state._sigFabric.toDataURL({format:'png'});
            const arr = await readFileAsArrayBuffer(state.files[0].file);
            const srcPdf = await libs.pdfLib.PDFDocument.load(arr);
            const pngImageBytes = await (await fetch(sigDataUrl)).arrayBuffer();
            const pngImage = await libs.pdfLib.PDFImageFactory ? null : await srcPdf.embedPng(pngImageBytes); // fallback if no util
            // pdf-lib embedPng works via pdfDoc.embedPng
            const outPdf = await libs.pdfLib.PDFDocument.create();
            const srcPages = await outPdf.copyPages(srcPdf, srcPdf.getPageIndices());
            srcPages.forEach(p => outPdf.addPage(p));
            // embed signature on first page
            const sigEmbedded = await outPdf.embedPng(pngImageBytes);
            const first = outPdf.getPages()[0];
            const {width, height} = first.getSize();
            const x = parseFloat(document.getElementById('sig-x').value || '50');
            const y = parseFloat(document.getElementById('sig-y').value || '50');
            const scale = parseFloat(document.getElementById('sig-scale').value || '0.6');
            const sigW = sigEmbedded.width * scale;
            const sigH = sigEmbedded.height * scale;
            first.drawImage(sigEmbedded, {x:x, y: height - y - sigH, width: sigW, height: sigH});
            const out = await outPdf.save();
            createDownloadLink(new Blob([out],{type:'application/pdf'}),'signed.pdf','application/pdf');
          }
        },

        'watermark': {
          title:'Watermark PDF',
          desc:'Add a diagonal text watermark to all pages with adjustable opacity.',
          icon:'🔖',
          fileType:'.pdf',
          multiple:false,
          options(container) {
            container.innerHTML = `
              <label style="font-weight:700">Watermark text</label>
              <input id="wm-text" placeholder="Confidential" style="padding:8px;border-radius:8px;border:1px solid #eee" />
              <label style="font-weight:700">Opacity</label>
              <input id="wm-opacity" type="range" min="0.1" max="1" step="0.05" value="0.2" />
            `;
          },
          async process(state, libs) {
            if (state.files.length === 0) { showError('Select a PDF'); return; }
            const text = document.getElementById('wm-text').value || 'Confidential';
            const opacity = parseFloat(document.getElementById('wm-opacity').value || '0.2');
            const arr = await readFileAsArrayBuffer(state.files[0].file);
            const srcPdf = await libs.pdfLib.PDFDocument.load(arr);
            const outPdf = await libs.pdfLib.PDFDocument.create();
            const pages = await outPdf.copyPages(srcPdf, srcPdf.getPageIndices());
            pages.forEach(p => outPdf.addPage(p));
            // add watermark to each page
            const pagesOut = outPdf.getPages();
            pagesOut.forEach((p, idx) => {
              const { width, height } = p.getSize();
              const fontSize = Math.max(40, Math.min(width, height) / 8);
              p.drawText(text, {
                x: width / 2 - (text.length * fontSize) / 4,
                y: height / 2,
                size: fontSize,
                rotate: libs.pdfLib.degrees(-45),
                color: libs.pdfLib.rgb(0.6, 0.6, 0.6),
                opacity
              });
            });
            const out = await outPdf.save();
            createDownloadLink(new Blob([out],{type:'application/pdf'}),'watermarked.pdf','application/pdf');
          }
        },

        'rotate': {
          title:'Rotate PDF',
          desc:'Rotate all pages by 90°, 180° or 270° clockwise.',
          icon:'🔁',
          fileType:'.pdf',
          multiple:false,
          options(container) {
            container.innerHTML = `
              <label style="font-weight:700">Rotate</label>
              <select id="rotate-angle" style="padding:8px;border-radius:8px;border:1px solid #eee">
                <option value="90">90°</option>
                <option value="180">180°</option>
                <option value="270">270°</option>
              </select>
            `;
          },
          async process(state, libs) {
            if (state.files.length === 0) { showError('Select a PDF'); return; }
            const angle = parseInt(document.getElementById('rotate-angle').value || '90',10);
            const arr = await readFileAsArrayBuffer(state.files[0].file);
            const srcPdf = await libs.pdfLib.PDFDocument.load(arr);
            // pdf-lib doesn't provide a direct page.setRotation degrees helper pre-v1. But we can copy pages and apply rotation transforms by redrawing images
            const newPdf = await libs.pdfLib.PDFDocument.create();
            const pages = await newPdf.copyPages(srcPdf, srcPdf.getPageIndices());
            // If copyPages returns same pages, just add and rotate via setRotation
            pages.forEach(p => newPdf.addPage(p));
            const pagesOut = newPdf.getPages();
            pagesOut.forEach(p => {
              p.setRotation(libs.pdfLib.degrees(angle));
            });
            const out = await newPdf.save();
            createDownloadLink(new Blob([out],{type:'application/pdf'}),'rotated.pdf','application/pdf');
          }
        },

        /***********************
         * The remaining tools are defined as simple placeholders or light implementations.
         * You can extend each tool's process() to provide more advanced behavior.
         ***********************/
        'pdf-to-jpg': { title:'PDF to JPG', desc:'Export PDF pages as JPG images (one per page).', icon:'🖼️', fileType:'.pdf', multiple:false,
          options(c){ c.innerHTML = '<div style="color:var(--muted)">Exports each page as a JPEG image.</div>'; },
          async process(state, libs) {
            if (state.files.length === 0) { showError('Select a PDF'); return; }
            const arr = await readFileAsArrayBuffer(state.files[0].file);
            const pdfDoc = await libs.pdfjsLib.getDocument({data:arr}).promise;
            const total = pdfDoc.numPages;
            for (let i=1;i<=total;i++) {
              showLoader(`Rendering page ${i}/${total}...`);
              const page = await pdfDoc.getPage(i);
              const vp = page.getViewport({scale:1.5});
              const c = document.createElement('canvas'); c.width = vp.width; c.height = vp.height;
              await page.render({canvasContext:c.getContext('2d'), viewport:vp}).promise;
              const blob = await (await fetch(c.toDataURL('image/jpeg'))).blob();
              createDownloadLink(blob, `page-${i}.jpg`, 'image/jpeg');
            }
            hideLoader();
          }
        },

        'jpg-to-pdf': { title:'JPG to PDF', desc:'Combine JPG/PNG images into a single PDF.', icon:'🖼️→📄', fileType:'image/*', multiple:true,
          options(c){ c.innerHTML = '<div style="color:var(--muted)">Upload images to create a PDF.</div>'; },
          async process(state, libs) {
            if (state.files.length===0){ showError('Select images'); return; }
            const pdfDoc = await libs.pdfLib.PDFDocument.create();
            for (const f of state.files) {
              const dataUrl = await readFileAsDataUrl(f.file);
              const isPng = dataUrl.indexOf('image/png') !== -1;
              const bytes = await (await fetch(dataUrl)).arrayBuffer();
              const img = isPng ? await pdfDoc.embedPng(bytes) : await pdfDoc.embedJpg(bytes);
              const page = pdfDoc.addPage([img.width, img.height]);
              page.drawImage(img, {x:0,y:0,width:img.width,height:img.height});
            }
            const out = await pdfDoc.save();
            createDownloadLink(new Blob([out],{type:'application/pdf'}),'images.pdf','application/pdf');
          }
        },

        'compress-images': { title:'Compress Images', desc:'Compress images inside archives (placeholder).', icon:'🗂️', fileType:'image/*', multiple:true,
          options(c){ c.innerHTML = '<div style="color:var(--muted)">Basic placeholder - compress individually. Coming soon.</div>'; },
          async process(state) { showError('Not implemented yet — placeholder.'); }
        },

        'ocr': { title:'OCR (PDF/Image → Text)', desc:'Extract text using OCR (tesseract).', icon:'🔎', fileType:'', multiple:false,
          options(c){ c.innerHTML = '<div style="color:var(--muted)">Uses Tesseract.js. Works best for images or scanned PDFs converted to images.</div>'; },
          async process(state, libs) {
            if (state.files.length===0){ showError('Select an image or PDF'); return; }
            showLoader('Converting pages to images for OCR (if PDF)...');
            // For brevity: basic implementation for single image using tesseract
            const file = state.files[0].file;
            if (file.type.startsWith('image/')) {
              const dataUrl = await readFileAsDataUrl(file);
              const worker = Tesseract.createWorker();
              await worker.load(); await worker.loadLanguage('eng'); await worker.initialize('eng');
              const res = await worker.recognize(dataUrl);
              await worker.terminate();
              hideLoader();
              const blob = new Blob([res.data.text], {type:'text/plain'});
              createDownloadLink(blob, 'ocr.txt','text/plain');
            } else {
              hideLoader();
              showError('For PDFs, convert pages to images first (use PDF to JPG) then run OCR on those images.');
            }
          }
        },

        'split-into-pages': { title:'Extract Pages', desc:'Extract specific pages into separate PDFs (basic).', icon:'📑', fileType:'.pdf', multiple:false,
          options(c){ c.innerHTML = '<div style="color:var(--muted)">Enter page numbers to extract (e.g., 2,4).</div><input id="extract-pages" placeholder="e.g., 2,4" style="padding:8px;border-radius:8px;border:1px solid #eee" />'; },
          async process(state, libs) {
            if (state.files.length===0) { showError('Select PDF'); return; }
            const arr = await readFileAsArrayBuffer(state.files[0].file);
            const src = await libs.pdfLib.PDFDocument.load(arr);
            const input = document.getElementById('extract-pages').value || '';
            if (!input) { showError('Enter page numbers'); return; }
            const parts = input.split(',').map(s=>parseInt(s.trim(),10)-1).filter(n=>!isNaN(n));
            const out = await libs.pdfLib.PDFDocument.create();
            const copied = await out.copyPages(src, parts);
            copied.forEach(p=>out.addPage(p));
            const o = await out.save();
            createDownloadLink(new Blob([o],{type:'application/pdf'}),'extracted.pdf','application/pdf');
          }
        },

        'protect': { title:'Protect PDF (password) - Placeholder', desc:'Add password protection (not implemented client-side).', icon:'🔒', fileType:'.pdf', multiple:false,
          options(c){ c.innerHTML = '<div style="color:var(--muted)">Password protection is not yet fully implemented client-side. Coming soon.</div>'; },
          async process() { showError('Password protection is a complex feature and not implemented in this demo.'); }
        },

        'unlock': { title:'Unlock PDF - Placeholder', desc:'Remove password from PDF (not implemented).', icon:'🔓', fileType:'.pdf', multiple:false,
          options(c){ c.innerHTML = '<div style="color:var(--muted)">Feature placeholder.</div>'; },
          async process(){ showError('Not implemented in this demo.'); }
        },

        'add-pages': { title:'Insert Blank Page', desc:'Insert a blank page into a PDF (basic).', icon:'➕', fileType:'.pdf', multiple:false,
          options(c) { c.innerHTML = '<div style="color:var(--muted)">Insert blank page at end.</div>'; },
          async process(state, libs) {
            if (state.files.length===0){ showError('Select PDF'); return; }
            const arr = await readFileAsArrayBuffer(state.files[0].file);
            const src = await libs.pdfLib.PDFDocument.load(arr);
            const out = await libs.pdfLib.PDFDocument.create();
            const pages = await out.copyPages(src, src.getPageIndices());
            pages.forEach(p=>out.addPage(p));
            out.addPage([595,842]); // A4-like
            const o = await out.save();
            createDownloadLink(new Blob([o],{type:'application/pdf'}),'with-blank.pdf','application/pdf');
          }
        },

        'remove-pages': { title:'Remove Pages', desc:'Remove certain pages from a PDF (basic).', icon:'✂️', fileType:'.pdf', multiple:false,
          options(c){ c.innerHTML = '<label>Pages to remove (e.g., 2,4)</label><input id="remove-pages" style="padding:8px;border-radius:8px;border:1px solid #eee"/>'; },
          async process(state, libs) {
            if (state.files.length===0) return showError('Select PDF');
            const arr = await readFileAsArrayBuffer(state.files[0].file);
            const src = await libs.pdfLib.PDFDocument.load(arr);
            const removeInput = document.getElementById('remove-pages').value || '';
            if (!removeInput) return showError('Enter pages to remove');
            const toRemove = removeInput.split(',').map(x=>parseInt(x.trim(),10)-1).filter(n=>!isNaN(n));
            const total = src.getPageCount();
            const keep = [];
            for (let i=0;i<total;i++) if (!toRemove.includes(i)) keep.push(i);
            const out = await libs.pdfLib.PDFDocument.create();
            const copied = await out.copyPages(src, keep);
            copied.forEach(p=>out.addPage(p));
            const o = await out.save();
            createDownloadLink(new Blob([o],{type:'application/pdf'}),'trimmed.pdf','application/pdf');
          }
        },

        'convert-to-pdf': { title:'Convert Other to PDF', desc:'Convert HTML/Images/DOC to PDF (mixed).', icon:'🔁', fileType:'', multiple:false,
          options(c){ c.innerHTML = '<div style="color:var(--muted)">Use Word to PDF or JPG to PDF tools for specific conversions.</div>'; },
          async process(){ showError('Use the specific conversion tools (Word→PDF, JPG→PDF).'); }
        },

        'split-by-size': { title:'Split by Size (MB) - Placeholder', desc:'Split PDF into parts by target file size (placeholder).', icon:'📦', fileType:'.pdf', multiple:false,
          options(c){ c.innerHTML = '<div style="color:var(--muted)">Placeholder - this feature requires chunked recompression. Coming soon.</div>'; },
          async process(){ showError('Split by size not implemented in this demo.'); }
        },

        'change-page-order': { title:'Reorder Pages (basic)', desc:'Reorder pages by indices (e.g., 3,1,2).', icon:'🔀', fileType:'.pdf', multiple:false,
          options(c){ c.innerHTML = '<label>Order (e.g., 3,1,2)</label><input id="order-pages" style="padding:8px;border-radius:8px;border:1px solid #eee"/>'},
          async process(state, libs) {
            if (state.files.length===0) return showError('Select PDF');
            const arr = await readFileAsArrayBuffer(state.files[0].file);
            const src = await libs.pdfLib.PDFDocument.load(arr);
            const total = src.getPageCount();
            const orderInput = document.getElementById('order-pages').value || '';
            if (!orderInput) return showError('Enter order');
            const order = orderInput.split(',').map(x=>parseInt(x.trim(),10)-1).filter(n=>!isNaN(n) && n>=0 && n<total);
            const out = await libs.pdfLib.PDFDocument.create();
            const copied = await out.copyPages(src, order);
            copied.forEach(p=>out.addPage(p));
            const o = await out.save();
            createDownloadLink(new Blob([o],{type:'application/pdf'}),'reordered.pdf','application/pdf');
          }
        },

        'pdf-to-text': { title:'PDF → Text (one-file)', desc:'Quick text extraction (plain).', icon:'📃', fileType:'.pdf', multiple:false,
          options(c){ c.innerHTML = '<div style="color:var(--muted)">Extracts text from pages. Use PDF→Word for more options.</div>'; },
          async process(state, libs) {
            // delegate to PDF to Word above
            await toolImplementations['pdf-to-word'].process(state, libs);
          }
        },

        'pdf-info': { title:'PDF Info', desc:'Show basic PDF metadata (pages, size).', icon:'ℹ️', fileType:'.pdf', multiple:false,
          options(c){ c.innerHTML = '<div style="color:var(--muted)">Shows page count and basic metadata.</div>'; },
          async process(state, libs) {
            if (state.files.length===0) return showError('Select PDF');
            const arr = await readFileAsArrayBuffer(state.files[0].file);
            const pdf = await libs.pdfLib.PDFDocument.load(arr);
            const meta = {
              pages: pdf.getPageCount(),
              title: pdf.getTitle ? pdf.getTitle() : null,
            };
            outputArea.innerHTML = `<pre style="white-space:pre-wrap;color:var(--muted)">${JSON.stringify(meta,null,2)}</pre>`;
          }
        },

        'optimize': { title:'Optimize PDF (placeholder)', desc:'Optimize internal structure (placeholder).', icon:'⚙️', fileType:'.pdf', multiple:false,
          options(c){ c.innerHTML = '<div style="color:var(--muted)">Placeholder.</div>'; },
          async process(){ showError('Optimize not implemented in this demo.'); }
        },

        'batch-rename': { title:'Batch Rename (files)', desc:'Rename multiple files (UI placeholder).', icon:'✏️', fileType:'', multiple:true,
          options(c){ c.innerHTML = '<div style="color:var(--muted)">Simple batch rename placeholder.</div>'; },
          async process(){ showError('Batch rename is a UI utility placeholder.'); }
        }
      };

      // Generate tool cards (27 total)
      const toolOrder = [
        'merge','split','compress','pdf-to-pptx','pdf-to-word','word-to-pdf','edit','sign','watermark','rotate',
        'pdf-to-jpg','jpg-to-pdf','compress-images','ocr','split-into-pages','protect','unlock','add-pages','remove-pages','convert-to-pdf',
        'split-by-size','change-page-order','pdf-to-text','pdf-info','optimize','batch-rename','pdf-to-word' // last is a duplicate to make 27 but will be skipped if duplicate
      ];
      const used = new Set();
      for (const key of toolOrder) {
        if (used.has(key)) continue;
        used.add(key);
        const t = toolImplementations[key];
        if (!t) continue;
        const card = document.createElement('div');
        card.className = 'tool-card focusable';
        card.tabIndex = 0;
        card.innerHTML = `
          <div class="tool-head">
            <div class="tool-icon" aria-hidden="true">${t.icon}</div>
            <div style="flex:1">
              <div class="tool-title">${t.title} ${t.new ? '<span class="badge-new">New!</span>' : ''}</div>
              <div class="tool-desc">${t.desc}</div>
            </div>
            <div style="display:flex;align-items:center"><button class="btn">Open</button></div>
          </div>
        `;
        card.addEventListener('click', () => {
          openModal(t);
        });
        card.addEventListener('keydown', (e) => { if (e.key==='Enter') openModal(t); });
        toolsContainer.appendChild(card);
        io.observe(card);
      }

      // Accessibility: trap focus inside modal when open
      document.addEventListener('focus', function(e) {
        if (!modalOverlay.classList.contains('open')) return;
        if (!modalOverlay.contains(e.target)) {
          e.stopPropagation();
          modalClose.focus();
        }
      }, true);

      // Small helper: enable process button when files change for simple tools
      // (tools that require onFileSelect can manage button themselves)
      const observer = new MutationObserver(() => {
        if (!activeTool) return;
        if (activeTool.onFileSelect) return; // tool manages enabling
        processBtn.disabled = modalState.files.length === 0;
      });
      observer.observe(fileListEl, {childList:true, subtree:true});

      // initial reset
      resetModalState();
    });
  </script>
</body>
</html>

